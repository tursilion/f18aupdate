* F18A In-System Updater
* TI-99/4A with CF7
*
* @author Matthew Hagerty
* @author Rasmus (lastname?)
* @date July 2014
* @version 1.6.2
*
* To update the updater:
* Run CRC.jar on .bin bitstream
* Copy CRC data into this file
* Compile to TIDisk as F18AUPD
* Convert .bin bitstream to TI-File (tools->convert PC to TI file) F18ABIN, INT/FIX, 128, Binary
* Copy F18ABIN to CF7 disk image
* Copy F18AUPD to CF7 disk image
* Copy CF7 disk image to CFcard
*
* When done beta testing, run in Classic99 to get the CHKSUM value and uncomment
* the checksum test for final distribution.
*
* Checksum values for each revision:
* 9B68 V1.5 Release
* 58AD V1.63 Stable - new NT2, prior to blitter update
* CEBE V1.64 Stable
* 6623 V1.65 Stable
* D555 V1.66 Stable
* E475 V1.67 Stable
* 4F34 V1.68 Stable
* 56A4 V1.69 Stable
* D7AE V1.691 Stable
* 12FF V1.692 Stable
* 40CC V1.6 Release
* A3B5 V1.7 Release
* F981 V1.8 Release

       DEF  START
       REF  DSRLNK,KSCAN

*      Configuration
*      See also section at end of file
FILE1S EQU  166                 * Size of file 1 (KB)
FILE2S EQU  46                  * Size of file 2 (KB)
BLKSIZ EQU  2                   * Read block size (KB)
FRMVER EQU  >0108               * Firmware version
GPUPRG EQU  >3000               * GPU program start

*      Constants
PGITOT EQU  FILE1S+FILE2S/BLKSIZ
PGIW   EQU  8*30                * Progress indicator width (pixels)

VDPRD  EQU  >8800               * VDP read data
VDPSTA EQU  >8802               * VDP status
VDPWD  EQU  >8C00               * VDP write data
VDPWA  EQU  >8C02               * VDP set read/write address
KEYDEV EQU  >8374               * Keyboard device
KEY    EQU  >8375               * Key pressed
STATUS EQU  >837C               * Key status
FNPNTR EQU  >8356               * File name pointer

*      VDP Memory Map
NAMETB EQU  >0000               * Name table
COLRTB EQU  >0380               * Color table
PTRNTB EQU  >0800               * Pattern table
SPRATB EQU  >0300               * Sprite attribute table
SPRPTB EQU  >0800               * Sprite pattern table
PAB    EQU  >0F00               * Peripheral address block
PABBUF EQU  >1000               * File data buffer

*      GPU Equates
CSON   EQU  >03A0               * SPI chip select enable
CSOFF  EQU  >03C0               * SPI chip select disable

CMD_RD EQU  >0B00               * Fast Read
CMD_RS EQU  >0500               * Read Status Register
CMD_WE EQU  >0600               * Write Enable
CMD_PP EQU  >0200               * Page Program
CMD_SE EQU  >D800               * Sector Erase


*      Start address of host-side code
       AORG >A000
CHKSUM DATA >F981               * Use emulator to determine value once code is finalized.
START  LIMI 0
       LWPI >8300
*      Checksum the code to help ensure it loaded from disk
*      without error.
       LI   R0,START
       CLR  R1
       LI   R2,CPUEND-START/2
CSUM01 A    *R0+,R1
       DEC  R2
       JNE  CSUM01
       LI   R0,GSTART
       LI   R2,GPUEND-GSTART/2
CSUM02 A    *R0+,R1
       DEC  R2
       JNE  CSUM02
*      Checksum test disabled during updates.
       C    R1,@CHKSUM
       JNE  QUIT

       LWPI WRKSP
       LI   R10,STACK
*      Boot tracking
       BL   @BOOTTR
*      Detect F18A
       BL   @F18ADT
*      Graphics mode
       BL   @GMODE
*      Check for F18A
       MOV  @F18A,R0
       JNE  MAIN1
*      Diplay error if not present
       LI   R0,11*32+7+NAMETB   * Position
       LI   R1,F18ERR           * Source address
       LI   R2,17               * Length
       BL   @VMBW
       JMP  ENDIT

*      Copy GPU code to VDP RAM
MAIN1  LI   R0,GPUPRG
       LI   R1,GPUPRG
       LI   R2,GPUEND-GPUPRG
       BL   @VMBW

*      Display the checksum
       LI   R0,0*32+0+NAMETB  * Display the checksum at screen location 0
       MOV  @CHKSUM,R1
       BL   @HEXDMP

*      Check that all files are present
       LI   R0,FILEN1           * Bit stream file
       LI   R2,FILEL1
       BL   @CKFILE
       MOV  R0,R0               * Check for error
       JNE  ENDIT
       LI   R0,FILEN2           * Extra data file
       LI   R2,FILEL2
       BL   @CKFILE
       MOV  R0,R0               * Check for error
       JNE  ENDIT
*      Display initial information
       BL   @DSPINF
       MOV  R0,R0               * Check for quit
       JNE  QUIT
*      Initialize progress indicator
       BL   @INIPGI
*      Display power message
       LI   R0,8*32+1+NAMETB
       LI   R1,POWER
       LI   R2,29
       BL   @VMBW

*      Call GPU initialize routine
       BL   @STSCLR
       LI   R0,GPUINI
       BL   @DO_GPU

*      Read bit stream file
       BL   @RDBIT
       MOV  R0,R0               * Check for error
       JNE  ENDIT
*      Read extra data file
       BL   @RDEXT
       MOV  R0,R0               * Check for error
       JNE  ENDIT

*      Call GPU finalization routine
       LI   R0,GPUUPD
       BL   @DO_GPU

       BL   @VERIFY
       MOV  R0,R0             * R0 == >0000 if successful
       JNE  MAIN1             * Recopy GPU code to reset initial data variables

*      Call GPU clean up routine
       LI   R0,GPUCLN
       BL   @DO_GPU

*      Display completed messages
       LI   R0,8*32+NAMETB    * Clear area
       LI   R1,>2000
       LI   R2,64
       BL   @VSMW

       LI   R0,8*32+4+NAMETB
       LI   R1,UPDCOM
       LI   R2,23
       BL   @VMBW

       LI   R0,9*32+4+NAMETB
       LI   R1,PRESSA
       LI   R2,23
       BL   @VMBW

*      Wait for keypress
ENDIT  CLR  @KEYDEV
ENDLP  BLWP @KSCAN
       MOV  @STATUS,R0
       JEQ  ENDLP
*      Quit
QUIT   LWPI >83E0
       LIMI 2
       BLWP @>0000
*// MAIN


**
* Display R1 as a hex number at screen location in R0
* Destroys R2
*
HEX    TEXT '0123456789ABCDEF'
HEXDMP
       MOV  R11,R2            * Save return address
       BL   @VWAD
       MOV  R2,R11            * Restore return address

       MOV  R1,R2
       ANDI R2,>F000          * Isolate the first digit
       SRL  R2,12             * Convert to a number
       MOVB @HEX(R2),@VDPWD   * Convert to ASCII and write to the screen

       MOV  R1,R2
       ANDI R2,>0F00
       SRL  R2,8
       MOVB @HEX(R2),@VDPWD

       MOV  R1,R2
       ANDI R2,>00F0
       SRL  R2,4
       MOVB @HEX(R2),@VDPWD

       MOV  R1,R2
       ANDI R2,>000F
       MOVB @HEX(R2),@VDPWD

       B    *R11
*// HEXDMP


**
* Call a GPU routine and wait for it to complete
* R0 = address of GPU routine in VRAM
*
DO_GPU
       MOV  R11,*R10+         * Push return address onto the stack

       MOV  R0,R1             * Save R0
       SRL  R0,8              * Move MSB to LSB
       AI   R0,>3600          * VR36 = MSB of GPU address
       BL   @VWTR

       ANDI R1,>00FF
       AI   R1,>3700          * VR37 = LSB of GPU address
       MOV  R1,R0
       BL   @VWTR

*      Wait for the GPU to finish and go idle.
       LI   R0,>0F02          * Set the status port to read SR2
       BL   @VWTR
DO_IDL MOVB @VDPSTA,R1
       JLT  DO_IDL            * MSbit = '1' while GPU is running.  Makes the byte a negative value
       LI   R0,>0F00          * Set status port to read SR0
       BL   @VWTR

       DECT R10               * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// DO_GPU


*********************************************************************
*
* Display initial information
*
DSPINF MOV  R11,*R10+           * Push return address onto the stack
*      Display info
       LI   R0,2*32+6+NAMETB
       LI   R1,F18UPD
       LI   R2,20
       BL   @VMBW

       LI   R0,8*32+NAMETB
       LI   R1,>2000
       LI   R2,64
       BL   @VSMW

       LI   R0,8*32+7+NAMETB
       LI   R1,PRESSP
       LI   R2,18
       BL   @VMBW

       LI   R0,9*32+10+NAMETB
       LI   R1,PRESSQ
       LI   R2,12
       BL   @VMBW

*      Display version numbers
       LI   R0,4*32+8+NAMETB
       LI   R1,YVRLBL
       LI   R2,14
       BL   @VMBW
       MOV  @F18VER,R0
       BL   @DSPVER

       LI   R0,5*32+8+NAMETB
       LI   R1,VERLBL
       LI   R2,14
       BL   @VMBW
       LI   R0,FRMVER
       BL   @DSPVER

*      Check keys
       CLR  @KEYDEV
DSPIN1 BLWP @KSCAN
       CB   @P,@KEY
       JEQ  DSPIN3
       CB   @Q,@KEY
       JEQ  DSPIN2
       JMP  DSPIN1
*      Quit
DSPIN2 SETO R0                  * Signal quit
       JMP  DSPIN4
*      Clear info
DSPIN3 BL   @DSPCLR
       CLR  R0                  * Signal continue
*      Return
DSPIN4 DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// DSPINF


**
* Clears lines 8 to 13
*
DSPCLR
       MOV  R11,*R10+           * Push return address onto the stack
       LI   R0,8*32+NAMETB
       LI   R1,>2000
       LI   R2,192
       BL   @VSMW

       DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// DSPCLR


**
* Clears lines 14 to 20
*
STSCLR
       MOV  R11,*R10+           * Push return address onto the stack
       LI   R0,14*32+NAMETB
       LI   R1,>2000
       LI   R2,224
       BL   @VSMW

       DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// STSCLR


*********************************************************************
*
* Display version No
*
* RO contains primary version number in MSB
* and secondary version number in LSB
*
DSPVER MOV  R0,R1
       AI   R1,>3000            * Add ASCII code for 0
       MOVB R1,@VDPWD
       LI   R1,>2E00            * Full stop
       MOVB R1,@VDPWD
       MOV  R0,R1               * LSB
       SWPB R1
       AI   R1,>3000
       MOVB R1,@VDPWD
       B    *R11
*// DPSVER

*********************************************************************
*
* Read bit stream file
*
RDBIT  MOV  R11,*R10+           * Push return address onto the stack
*      Setup variables and callback
       LI   R0,1                * File number
       MOV  R0,@FILENO
       CLR  @BLKNO
       LI   R0,FL1CRC           * CRC table
       MOV  R0,@CRCTBL
       LI   R0,FILE1S/BLKSIZ    * Number of blocks to read
       MOV  R0,@BLKCNT
       LI   R0,CALLBK           * Callback adress from RDFILE
       MOV  R0,@FILECB
       LI   R0,FILEN1           * File name
       LI   R2,FILEL1           * File name length
*      Call the file reading routine
       BL   @RDFILE
*      Return
       DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// RDBIT

*********************************************************************
*
* Read extra data file
*
RDEXT  MOV  R11,*R10+           * Push return address onto the stack
*      Setup variables and callback
       LI   R0,2                * File number
       MOV  R0,@FILENO
       CLR  @BLKNO
       LI   R0,FL2CRC           * CRC table
       MOV  R0,@CRCTBL
       LI   R0,FILE2S/BLKSIZ    * Number of blocks to read
       MOV  R0,@BLKCNT
       LI   R0,CALLBK           * Callback adress from RDFILE
       MOV  R0,@FILECB
       LI   R0,FILEN2           * File name
       LI   R2,FILEL2           * File name length
*      Call the file reading routine
       BL   @RDFILE
*      Return
       DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// RDEXT

*********************************************************************
*
* Callback routine after block is read
*
CALLBK MOV  R11,*R10+           * Push return address onto the stack
*      Update progress indicator
       INC  @PGICNT
       BL   @UPDPGI
*      Setup parameters for GPU routine
       LI   R0,GPUFNO           * File number
       LI   R1,FILENO
       LI   R2,2
       BL   @VMBW
       LI   R0,GPUBNO           * Block number
       LI   R1,BLKNO
       LI   R2,2
       BL   @VMBW
       LI   R0,GPUCRC           * CRC checksum
       MOV  @BLKNO,R1
       SLA  R1,1                * Convert to word offset
       A    @CRCTBL,R1
       LI   R2,2
       BL   @VMBW
       LI   R0,GPURES           * Clear result
       CLR  R1
       LI   R2,2
       BL   @VSMW
*      Call GPU routine
       LI   R0,GPUCPY/256+>3600              * High byte
       BL   @VWTR
       LI   R0,GPUCPY
       ANDI R0,>00FF
       AI   R0,>3700                         * Low byte
       BL   @VWTR
*      Wait for GPU completion
CALLB1 CLR  R1
       LI   R0,GPURES+1
       BL   @VSBR
       MOV  R1,R1
       JEQ  CALLB1
       CI   R1,>0100            * Check for success
       JEQ  CALLB2
*      Display error message
       LI   R0,11*32+9+NAMETB  * Position
       LI   R1,CRCERR           * Source address
       LI   R2,9                * Length
       BL   @VMBW
       SETO R0
       JMP  CALLB3
CALLB2 CLR  R0
*      Update block number
CALLB3 INC  @BLKNO
*      Return
       DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// CALLBK


**
* Verify the data written to the final SPI sectors.
* Similar to the call-back function but does not
* need to read the data files from disk, only passes
* the file no, block no, and CRC to the GPU verify routine.
*
* Returns >0000 if successful, otherwise >FFFF
*
VERIFY
       MOV  R11,*R10+         * Push return address onto the stack
       BL   @INIPGI

*      Setup file 1
       LI   R0,1
       MOV  R0,@FILENO
       LI   R0,GPUFNO         * File number
       LI   R1,FILENO
       LI   R2,2
       BL   @VMBW

       CLR  @BLKNO            * Start at block 0

       LI   R0,FL2CRC-FL1CRC
       SRA  R0,1              * Get the number of CRC values for the file
       MOV  R0,@BLKCNT

       LI   R0,FL1CRC         * CRC table
       MOV  R0,@CRCTBL

       BL   @VFYFIL
       MOV  R0,R0             * R0 == >0000 if successful
       JNE  VERRET

*      Setup file 2
       LI   R0,2
       MOV  R0,@FILENO
       LI   R0,GPUFNO         * File number
       LI   R1,FILENO
       LI   R2,2
       BL   @VMBW

       CLR  @BLKNO            * Start at block 0

       LI   R0,FLCRCE-FL2CRC
       SRA  R0,1              * Get the number of CRC values for the file
       MOV  R0,@BLKCNT

       LI   R0,FL2CRC         * CRC table
       MOV  R0,@CRCTBL

       BL   @VFYFIL

*      Return
VERRET
       DECT R10               * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// VERIFY


**
* Drives the CRC error value and block count to the GPU verify routine
* that will CRC check the block from the flash.
*
VFYFIL
       MOV  R11,*R10+         * Push return address onto the stack

*      Update progress indicator
VRFY05
       INC  @PGICNT
       BL   @UPDPGI

       LI   R0,GPUBNO         * Block number
       LI   R1,BLKNO
       LI   R2,2
       BL   @VMBW

       LI   R0,GPUCRC         * CRC checksum
       MOV  @CRCTBL,R1
       LI   R2,2
       BL   @VMBW

       LI   R0,GPURES         * Clear result
       CLR  R1
       LI   R2,2
       BL   @VSMW

*      Call GPU routine
       LI   R0,GPUVFY/256+>3600              * High byte
       BL   @VWTR
       LI   R0,GPUVFY
       ANDI R0,>00FF
       AI   R0,>3700                         * Low byte
       BL   @VWTR

*      Wait for GPU completion
VRFY20 CLR  R1
       LI   R0,GPURES+1       * Get the LSB of the return value
       BL   @VSBR
       MOV  R1,R1
       JEQ  VRFY20
       CI   R1,>0100          * 1 == success
       JNE  VFYERR

       INC  @BLKNO            * Update block number
       INCT @CRCTBL           * Next CRC value
       DEC  @BLKCNT           * Count the block
       JNE  VRFY05

       CLR  R0                * Return R0 = >0000
       JMP  VFYRET

*      Display error message
VFYERR
       BL   @DSPCLR
       LI   R0,11*32+0+NAMETB
       LI   R1,TVFY01
       LI   R2,64             * Two lines of text, 32 bytes each
       BL   @VMBW
       SETO R0                * Return R0 = >FFFF

*      Return
VFYRET
       DECT R10               * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// VFYFIL


*********************************************************************
*
* Read file
*
* R0:   Address of file name
* R2:   Length of file name
* @RECCNT contains number of records to read
* @FILECB contains address of routine to call when a record is read
*
RDFILE MOV  R11,*R10+           * Push return address onto the stack
       MOV  R2,R1
       AI   R1,5
       MOV  R1,@FILENL          * Set file name length
       LI   R1,FILENM
SETFNM MOVB *R0+,*R1+           * Set the file name
       DEC  R2
       JNE  SETFNM
       LI   R0,>2000            * Pad with spaces
SETFN1 CI   R1,PABDTE
       JEQ  SETFN2
       MOVB R0,*R1+
       JMP  SETFN1
*      Copy PAB data into VDP RAM
SETFN2 LI   R0,PAB
       LI   R1,PABDAT
       LI   R2,PABDTE-PABDAT
       BL   @VMBW
*      Open
       LI   R0,PAB+9            * Pointer to name length
       MOV  R0,@FNPNTR          * Store in >8356
       BLWP @DSRLNK             * Open file
       DATA 8
*      Check for errors
       LI   R0,PAB+1            * Get status byte
       BL   @VSBR
       ANDI R1,>E000            * Mask off error code
       JNE  FERROR
       MOVB @STATUS,R0
       COC  @COND,R0            * Check for device error
       JEQ  FERROR              * This doesn't seem to be working
*      Read
       LI   R0,PAB
       LI   R1,>0200            * READ op-code
       BL   @VSBW               * Change op-code to READ
BLKLP  LI   R0,BLKSIZ*8         * 8 records of 128 bytes per KB
       MOV  R0,@RECCNT
       LI   R0,PABBUF           * Setup destination address
       MOV  R0,@DSTADR
       CLR  R1
       LI   R2,BLKSIZ*1024
       BL   @VSMW               * Clear VDP buffer
RECLP  LI   R0,PAB+2            * Write destination to PAB
       LI   R1,DSTADR
       LI   R2,2
       BL   @VMBW
       LI   R0,PAB+9            * Pointer to name length
       MOV  R0,@FNPNTR          * Store in >8356
       BLWP @DSRLNK             * Read record from file
       DATA 8
*      Check for errors
       LI   R0,PAB+1            * Get status byte
       BL   @VSBR
       ANDI R1,>E000            * Mask off error code
       JNE  FERROR
       MOVB @STATUS,R0
       COC  @COND,R0            * Check for device error
       JEQ  FERROR              * This doesn't seem to be working
       LI   R0,PAB+5            * Get bytes read
       CLR  R1
       BL   @VSBR
       CI   R1,>8000            * Check if 128 bytes read
       JNE  FERROR
*      Update destination address
       MOV  @DSTADR,R0
       AI   R0,128
       MOV  R0,@DSTADR
*      Inner loop
       DEC  @RECCNT
       JNE  RECLP
*      Call callback routine
       MOV  @FILECB,R0
       BL   *R0
       MOV  R0,R0               * Check for error
       JNE  RDFEND
*      Outer loop
       DEC  @BLKCNT
       JNE  BLKLP
*      Close
       LI   R0,PAB
       LI   R1,>0100            * CLOSE op-code
       BL   @VSBW               * Change op-code to READ
       LI   R0,PAB+9            * Pointer to name length
       MOV  R0,@FNPNTR          * Store in >8356
       BLWP @DSRLNK             * Close file
       DATA 8
*      Signal success
       CLR  R0
       JMP  RDFEND
*      File error
FERROR SRL  R1,5                * Move error code bits into place in MSB
       CI   R1,>0500            * Error code 5 = end of file
       JNE  FERR1
       C    @ONE,@BLKCNT        * Check if we're at the last block
       JNE  FERR1
*      Call callback routine one last time
       MOV  @FILECB,R0
       BL   *R0
       MOV  R0,R0               * Check for error
       JNE  RDFEND
*      Signal success
       CLR  R0
       JMP  RDFEND
FERR1  AI   R1,>3000            * Add ASCII code for 0
       MOVB R1,@FILERR+11
*      Display error
       LI   R0,10*32+10+NAMETB  * Position
       LI   R1,FILERR           * Source address
       LI   R2,12               * Length
       BL   @VMBW
*      Signal error
       SETO R0
*      Return
RDFEND DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// RDFILE

*********************************************************************
*
* Check for file existence
*
* R0:   Address of file name
* R2:   Length of file name
*
CKFILE MOV  R11,*R10+           * Push return address onto the stack
       MOV  R2,R1
       AI   R1,5
       MOV  R1,@FILENL          * Set file name length
       LI   R1,FILENM
CKFIL1 MOVB *R0+,*R1+           * Set the file name
       DEC  R2
       JNE  CKFIL1
       LI   R0,>2000            * Pad with spaces
CKFIL2 CI   R1,PABDTE
       JEQ  CKFIL3
       MOVB R0,*R1+
       JMP  CKFIL2
*      Copy PAB data into VDP RAM
CKFIL3 LI   R0,PAB
       LI   R1,PABDAT
       LI   R2,PABDTE-PABDAT
       BL   @VMBW
*      Open
       LI   R0,PAB+9            * Pointer to name length
       MOV  R0,@FNPNTR          * Store in >8356
       BLWP @DSRLNK             * Open file
       DATA 8
*      Check for errors
       LI   R0,PAB+1            * Get status byte
       BL   @VSBR
       ANDI R1,>E000            * Mask off error code
       JNE  CKFIL4
*      Close
       LI   R0,PAB
       LI   R1,>0100            * CLOSE op-code
       BL   @VSBW               * Change op-code to READ
       LI   R0,PAB+9            * Pointer to name length
       MOV  R0,@FNPNTR          * Store in >8356
       BLWP @DSRLNK             * Close file
       DATA 8
*      Signal success
       CLR  R0
       JMP  CKFIL6
*      File error
CKFIL4 SRL  R1,5                * Move error code bits into place in MSB
       MOV  R1,R3               * Save it
       AI   R1,>3000            * Add ASCII code for 0
       MOVB R1,@FILERR+11       * Copy into error message
*      Display error
       LI   R0,10*32+10+NAMETB  * Position
       LI   R1,FILERR           * Source address
       LI   R2,12               * Length
       BL   @VMBW
       CI   R3,>0700            * Check for file not found
       JNE  CKFIL5
       LI   R0,12*32+2+NAMETB   * Position
       LI   R1,FNFERR           * Source address
       LI   R2,15               * Length
       BL   @VMBW
       LI   R0,12*32+17+NAMETB  * Position
       LI   R1,FILEDV
       MOV  @FILENL,R2          * Length
       BL   @VMBW
*      Signal error
CKFIL5 SETO R0
*      Return
CKFIL6 DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// CKFILE

*********************************************************************
*
* Boot tracking
*
* Code adapted from:
* 1.7. The Art Of Assembly — Part 7. Why A Duck?
* By Bruce Harrison 1991
*
* THE SECTION HERE AT LABEL OPEN PERFORMS "BOOT TRACKING"
* THAT IS, IT TELLS OUR PROGRAM WHICH DRIVE IT WAS LOADED FROM
*
BOOTTR MOV  @>83D0,R12          * GET THE CRU BASE IN R12
       MOV  @>83D2,R1           * GET THE ROM ADDRESS FOR DEVICE
       SBO  0                   * ENABLE THE ROM
       AI   R1,4                * ADDING FOUR PUTS US AT THE LENGTH BYTE
       MOVB *R1+,R2             * PLACE THAT IN R2 AND INCREMENT R1
       SRL  R2,8                * RIGHT JUSTIFY LENGTH IN R2
       LI   R3,FILEDV           * POINT TO TEXT BUFFER
BOOTT1 MOVB *R1+,*R3+           * MOV ONE BYTE FROM ROM TO TEXT BUFFER
       DEC  R2                  * FINISHED?
       JNE  BOOTT1              * NO, DO ANOTHER BYTE
       SBZ  0                   * DISABLE THE ROM
       B    *R11                * RETURN
*// BOOTTR

*********************************************************************
*
* Initialize progress indicator
*
INIPGI MOV  R11,*R10+           * Push return address onto the stack
       CLR  @PGICNT             * Clear counter
       LI   R0,21*32+NAMETB
       LI   R1,PGIDAT
       LI   R2,96
       BL   @VMBW
*      Return
       DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// INIPGI

*********************************************************************
*
* Update progress indicator
*
* Progress is controlled by @PGICNT (0 - (PGITOT-1))
*
UPDPGI MOV  R11,*R10+           * Push return address onto the stack
       LI   R3,PGIW             * Width of progress indicator
       MPY  @PGICNT,R3          * Multiply by progress counter
       LI   R0,PGITOT
       DIV  R0,R3               * Divide by total number of blocks
       LI   R0,22*32+1+NAMETB
       BL   @VWAD
*      Full patterns
       LI   R1,>0700            * Full pattern
       MOV  R3,R2
       SRA  R2,3                * Calculate number of full patterns
       JEQ  UPDPG1
UPDPG0 MOVB R1,@VDPWD           * Write full patterns to VDP
       DEC  R2
       JNE  UPDPG0
*      Partial pattern
UPDPG1 MOV  R3,R1
       ANDI R1,>0007            * Mod 8
       JEQ  UPDPG2
       DEC  R1
       SWPB R1
       MOVB R1,@VDPWD           * Write partial pattern to VDP
       SETO R1                  * Signal partial pattern
*      Empty patterns
UPDPG2 SRA  R3,3                * Calculate number of empty patterns
       LI   R2,30
       S    R3,R2               * 30 - full patterns
       MOV  R1,R1
       JEQ  UPDPG3
       DEC  R2                  * -1 if there is a partial pattern
UPDPG3 MOV  R2,R2
       JEQ  UPDPG5
       LI   R1,>2000            * Space
UPDPG4 MOVB R1,@VDPWD           * Write space to VDP
       DEC  R2
       JNE  UPDPG4
*      Return
UPDPG5 DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// INIPGI

*********************************************************************
*
* Detect F18A
*
F18ADT MOV  R11,*R10+           * Push return address onto the stack
*      F18A Unlock
       LI   R0,>391C            * VR1/57, value 00011100
       BL   @VWTR               * Write once
       BL   @VWTR               * Write twice, unlock
       LI   R0,>01E0            * VR1, value 11100000, a real sane setting
       BL   @VWTR               * Write reg
*      Copy GPU code to VRAM
       LI   R0,GPUPRG
       LI   R1,GPUDT
       LI   R2,GPUDTE-GPUDT
       BL   @VMBW
*      Set the GPU PC which also triggers it
       LI   R0,GPUPRG/256+>3600 * High byte
       BL   @VWTR
       LI   R0,>3700            * Low byte
       BL   @VWTR
*      Compare the result in GPUPRG
       LI   R0,GPUPRG
       BL   @VRAD
       MOVB @VDPRD,R0
       JEQ  F18AOK
       CLR  @F18A
       JMP  F18ADE
F18AOK SETO @F18A
*      Get the version number
       LI   R0,>0F0E            * Choose version status reg
       BL   @VWTR
       CLR  R0
       MOVB @VDPSTA,R0
       MOV  R0,R1
       ANDI R0,>F000
       SRL  R0,4                * MSB - major version no
       ANDI R1,>0F00
       SRL  R1,8
       SOC  R1,R0               * LSB - minor version no
       MOV  R0,@F18VER
       LI   R0,>0F00            * Choose ordinary status reg
       BL   @VWTR
F18ADE DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// F18ADT

GPUDT  CLR  @GPUPRG
       IDLE
GPUDTE

*********************************************************************
*
* Setup graphics mode
*
GMODE  MOV  R11,*R10+           * Push return address onto the stack
       LI   R0,>0000            * Reg 0: Graphics mode I,
       BL   @VWTR               * external video off
       LI   R0,>01C2            * Reg 1: 16K, display on, no interrupt,
       BL   @VWTR               * size = 1, mag = 0.
       LI   R0,>0200            * Reg 2: Name table
       BL   @VWTR               * NAMETB = >1800 (>06 * >400), >300 bytes
       LI   R0,>030E            * Reg 3: Color Table
       BL   @VWTR               * COLRTB = >0380 (>0E * >40), >20 bytes
       LI   R0,>0401            * Reg 4: Pattern Table
       BL   @VWTR               * PTRNTB = >0800 (>01 * >800), >800 bytes
       LI   R0,>0506            * Reg 5: Sprite Attribute Table
       BL   @VWTR               * SPRATB = >0300 (>06 * >80), >80 bytes
       LI   R0,>0601            * Reg 6: Sprite Pattern Table
       BL   @VWTR               * SPRPTB = >0800 (>01 * >800), >800 bytes
       LI   R0,>07F4            * Reg 7: Text-mode color and backdrop color
       BL   @VWTR               * Blue backdrop
*      Put a copy of Reg 1 at >83D4
       LI   R0,>C200
       MOVB R0,@>83D4
*      Disable sprites
       LI   R0,SPRATB
       LI   R1,>D000
       BL   @VSBW
*      Initialize color table
       LI   R0,COLRTB
       LI   R1,CLRSET
       LI   R2,>20              * 32 bytes
       BL   @VMBW
*      Clear name table
       LI   R0,NAMETB
       LI   R1,>2000            * Space
       LI   R2,>300             * 768 bytes
       BL   @VSMW
*      Initialize patterns
       LI   R0,PTRNTB
       LI   R1,PAT0
       LI   R2,16*8             * 16 patterns
       BL   @VMBW
*      Return
       DECT R10                 * Pop return address off the stack
       MOV  *R10,R11
       B    *R11
*// GMODE

*********************************************************************
*
* VDP Set Read Address
*
* R0   Address to set VDP address counter to
*
VRAD   MOVB @R0LB,@VDPWA            * Send low byte of VDP RAM write address
       ANDI R0,>3FFF                * Make sure the two MSbits are 00 for read
       MOVB R0,@VDPWA               * Send high byte of VDP RAM write address
       B    *R11
*// VRAD

*********************************************************************
*
* VDP Set Write Address
*
* R0   Address to set VDP address counter to
*
VWAD   MOVB @R0LB,@VDPWA            * Send low byte of VDP RAM write address
       ORI  R0,>4000                * Set the two MSbits to 01 for write
       MOVB R0,@VDPWA               * Send high byte of VDP RAM write address
       ANDI R0,>3FFF                * Restore R0 top two MSbits
       B    *R11
*// VWAD

*********************************************************************
*
* VDP Single Byte Write
*
* R0   Write address in VDP RAM
* R1   MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
VSBW   MOVB @R0LB,@VDPWA        * Send low byte of VDP RAM write address
       ORI  R0,>4000            * Set read/write bits 14 and 15 to write (01)
       MOVB R0,@VDPWA           * Send high byte of VDP RAM write address
       MOVB R1,@VDPWD           * Write byte to VDP RAM
       B    *R11
*// VSBW

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0   Starting write address in VDP RAM
* R1   MSB of R1 sent to VDP RAM
* R2   Number of times to write the MSB byte of R1 to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
VSMW   MOVB @R0LB,@VDPWA        * Send low byte of VDP RAM write address
       ORI  R0,>4000            * Set read/write bits 14 and 15 to write (01)
       MOVB R0,@VDPWA           * Send high byte of VDP RAM write address
VSMWLP MOVB R1,@VDPWD           * Write byte to VDP RAM
       DEC  R2                  * Byte counter
       JNE  VSMWLP              * Check if done
       B    *R11
*// VSMW

*********************************************************************
*
* VDP Multiple Byte Write
*
* R0   Starting write address in VDP RAM
* R1   Starting read address in CPU RAM
* R2   Number of bytes to send to the VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
VMBW   MOVB @R0LB,@VDPWA        * Send low byte of VDP RAM write address
       ORI  R0,>4000            * Set read/write bits 14 and 15 to write (01)
       MOVB R0,@VDPWA           * Send high byte of VDP RAM write address
VMBWLP MOVB *R1+,@VDPWD         * Write byte to VDP RAM
       DEC  R2                  * Byte counter
       JNE  VMBWLP              * Check if done
       B    *R11
*// VMBW

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
VSBR   MOVB @R0LB,@VDPWA        * Send low byte of VDP RAM write address
       MOVB R0,@VDPWA           * Send high byte of VDP RAM write address
       MOVB @VDPRD,R1           * Read byte from VDP RAM
       B    *R11
*// VSBR

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0   Starting read address in VDP RAM
* R1   Starting write address in CPU RAM
* R2   Number of bytes to read from VDP RAM
*
VMBR   MOVB @R0LB,@VDPWA        * Send low byte of VDP RAM write address
       MOVB R0,@VDPWA           * Send high byte of VDP RAM write address
VMBRLP MOVB @VDPRD,*R1+         * Read byte from VDP RAM
       DEC  R2                  * Byte counter
       JNE  VMBRLP              * Check if finished
       B    *R11
*// VMBR

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB    VDP register to write to
* R0 LSB    Value to write
*
VWTR   MOVB @R0LB,@VDPWA        * Send low byte (value) to write to VDP register
       ORI  R0,>8000            * Set up a VDP register write operation (10)
       MOVB R0,@VDPWA           * Send high byte (address) of VDP register
       B    *R11
*// VWTR

*********************************************************************
*
* Data section
*
*WRKSP  BSS  32
WRKSP  EQU  >8300
R0LB   EQU  WRKSP+1             * R0 low byte reqd for VDP routines
*STACK  BSS  16
STACK  EQU  WRKSP+32

F18A   DATA >0000               * F18A detected
F18VER DATA >0000               * F18A version
BLKCNT DATA >0000               * Number of file blocks of 4K to read
RECCNT DATA >0000               * Number of file records to read
FILECB DATA >0000               * Address of file reading callback routine
DSTADR DATA >0000               * File destination address
BLKNO  DATA >0000               * Number of last block read
FILENO DATA >0000               * Number of current file
CRCTBL DATA >0000               * Base adress of current CRC table
PGICNT DATA >0000               * Progress indicator counter

PABDAT BYTE >00                 * I/O op-code (0=READ, 1=CLOSE, 2=READ)
       BYTE >0C                 * Flags: Fixed, Internal, Input, Sequential
       DATA PABBUF              * Data buffer address (VDP RAM)
       DATA >8000               * 128 bytes record length / bytes read
       DATA >0000               * Record number (not used for sequential)
FILENL DATA >000C               * File name length
FILEDV TEXT "DSK1."             * File device
FILENM TEXT "          "        * File name
PABDTE

*      Text
F18UPD TEXT "F18A FIRMWARE UPDATE"
YVRLBL TEXT " FOUND F18A: V"
VERLBL TEXT "UPDATE FILE: V"
PRESSP TEXT "PRESS P TO PROCEED"
PRESSQ TEXT "OR Q TO QUIT"
POWER  TEXT "* DO NOT TURN OFF THE POWER *"
UPDCOM TEXT ">>> UPDATE COMPLETE <<<"
PRESSA TEXT "POWER CYCLE YOUR SYSTEM"

FILERR TEXT "FILE ERROR N"
FNFERR TEXT "FILE NOT FOUND "
F18ERR TEXT "F18A NOT DETECTED"
CRCERR TEXT "FILE CRC ERROR"
TVFY01 TEXT "FLASH VERIFY ERROR! DO NOT POWER"
TFFY02 TEXT "OFF. PRESS P TO TRY UPDATE AGAIN"

*      Constants
ONE    DATA >0001
COND   DATA >0200
P      BYTE >50
Q      BYTE >51

*      Color sets
CLRSET BYTE >F0,>E0,>F0,>F0
       BYTE >F0,>F0,>F0,>F0
       BYTE >F0,>F0,>F0,>F0
       BYTE >F0,>F0,>F0,>F0
       BYTE >10,>10,>10,>10
       BYTE >10,>10,>10,>10
       BYTE >10,>10,>10,>10
       BYTE >10,>10,>10,>10

*      Progress indicator patterns
PAT0   DATA >8080,>8080,>8080,>8080
PAT1   DATA >C0C0,>C0C0,>C0C0,>C0C0
PAT2   DATA >E0E0,>E0E0,>E0E0,>E0E0
PAT3   DATA >F0F0,>F0F0,>F0F0,>F0F0
PAT4   DATA >F8F8,>F8F8,>F8F8,>F8F8
PAT5   DATA >FCFC,>FCFC,>FCFC,>FCFC
PAT6   DATA >FEFE,>FEFE,>FEFE,>FEFE
PAT7   DATA >FFFF,>FFFF,>FFFF,>FFFF
PAT8   DATA >0000,>0000,>0F08,>0B0A
PAT9   DATA >0000,>0000,>FF00,>FF00
PAT10  DATA >0000,>0000,>F010,>D050
PAT11  DATA >0A0B,>080F,>0000,>0000
PAT12  DATA >00FF,>00FF,>0000,>0000
PAT13  DATA >50D0,>10F0,>0000,>0000
PAT14  DATA >0A0A,>0A0A,>0A0A,>0A0A
PAT15  DATA >5050,>5050,>5050,>5050

*      Progress indicator
PGIDAT DATA >0809,>0909,>0909,>0909
       DATA >0909,>0909,>0909,>0909
       DATA >0909,>0909,>0909,>0909
       DATA >0909,>0909,>0909,>090A
       DATA >0E20,>2020,>2020,>2020
       DATA >2020,>2020,>2020,>2020
       DATA >2020,>2020,>2020,>2020
       DATA >2020,>2020,>2020,>200F
       DATA >0B0C,>0C0C,>0C0C,>0C0C
       DATA >0C0C,>0C0C,>0C0C,>0C0C
       DATA >0C0C,>0C0C,>0C0C,>0C0C
       DATA >0C0C,>0C0C,>0C0C,>0C0D

*      Configuration
FILEL1 EQU  7
FILEN1 TEXT "F18ABIN"
FILEL2 EQU  7
FILEN2 TEXT "F18AROM"
       EVEN
*      Cyclic Redundancy Check (CRC) checksums

FL1CRC DATA >B9EE,>81AC,>5697,>C018
       DATA >ACBC,>EDA7,>6239,>04CA
       DATA >F169,>CE10,>6C42,>616B
       DATA >E917,>64AC,>0186,>C730
       DATA >3A68,>E2D7,>31C9,>C185
       DATA >9D81,>CA03,>A920,>2F6E
       DATA >2296,>3F3B,>D7E9,>4A38
       DATA >E509,>9B8E,>5605,>7B25
       DATA >9D16,>DB4D,>0C02,>B0A7
       DATA >5223,>EE40,>E82B,>33A2
       DATA >77C8,>62DA,>5C9E,>4499
       DATA >F026,>19F6,>B4F4,>C2CF
       DATA >3A71,>DF12,>6BC1,>7A59
       DATA >FBCD,>6ADD,>8F4A,>F725
       DATA >A2AC,>ADEF,>FB91,>C09F
       DATA >3CC7,>DC9F,>6522,>8CCD
       DATA >0000,>0000,>7EEC,>59D4
       DATA >0B8E,>5729,>6668,>4477
       DATA >DC51,>CE4F,>20CA,>0000
       DATA >E5A9,>971F,>1345,>4A89
       DATA >E7BF,>FE48,>C0C7

FL2CRC DATA >E639,>9AED,>2914,>BA68
       DATA >0417,>FC80,>BF6C,>CFA9
       DATA >F43B,>CD62,>6DAA,>F53D
       DATA >1C0C,>65BB,>13C0,>982A
       DATA >7357,>3B93,>5AB5,>D296
       DATA >FA80,>265C,>69E1
FLCRCE
CPUEND

*********************************************************************
*
* GPU routines
*

*      Start address in VRAM of CPU code
       AORG GPUPRG
* GSTART needs to go on the first line of code so my checksum code has
* an address to work with.

**
* Clear high end SPI Flash sectors for a temp buffer
* Sectors 10 - 15 or >0A0000 to >0F0000
GPUINI
GSTART LI   R15,GPUPRG-2      * Set up the stack pointer

       LI   R4,14*32+0+NAMETB * Initialize the last line for display output
       MOV  R4,@LASTLN

       LI   R4,GMSG1          * "CLEARING SECTOR"
       LI   R5,GMSG1E-GMSG1
       BSTK @SHOWTXT          * Leaves R6 at end of displayed text

       LI   R1,>0A00
       LI   R2,6
       BSTK @SERASE

       A    @NEWLN,@LASTLN    * Next line for copy process
       IDLE
*// GPUINI


**
* Clean up sectors 10 - 15 or >0A0000 to >0F0000
GPUCLN
       A    @NEWLN,@LASTLN    * Next line for copy process
       LI   R4,GMSG7          * "CLEANING UP"
       LI   R5,GMSG7E-GMSG7
       BSTK @SHOWTXT          * Leaves R6 at end of displayed text

       LI   R1,>0A00
       LI   R2,6
       BSTK @SERASE

       IDLE
*// GPUCLN


*********************************************************************
* Copy data block to SPI staging sectors.  Called in a loop during
* the host system's disk read process.
*
* GPUFNO = current file number, 1-based
* GPUBNO = current file block number
* PABBUF = block of data to copy
* BLKSIZ = size of data block in KiB
*
GPUCPY
       MOV  @GPUFNO,R0        * Check the file being copied
       DEC  R0                * File numbers are 1-based
       JNE  CPY05
       LI   R9,>0A00          * Staging block for bit stream
       LI   R4,GMSG2          * "STAGING BIT STREAM"
       LI   R5,GMSG2E-GMSG2
       JMP  CPY10
CPY05
       LI   R9,>0F00          * Staging block for data file
       LI   R4,GMSG3          * "STAGING DATA"
       LI   R5,GMSG3E-GMSG3
CPY10
       BSTK @SHOWTXT          * Leaves R6 at end of displayed text

*      Check CRC
       BSTK @CHKCRC
       MOV  R0,R0             * Check for error
       JNE  CPYERR

*      Copy to SPI
*      The block number needs to be adjusted to a count of 256-byte blocks
       MOV  R9,R0
       LI   R1,BLKSIZ*1024/256
       MOV  @GPUBNO,R2
       MPY  R1,R2             * Multiply the block number by 256-byte chunks in one block
       A    R3,R0             * Add the 256-byte block count to the base address
       LI   R1,PABBUF
       LI   R2,BLKSIZ*1024
       BSTK @BWRITE           * Displays page in R0 (0-4095)

*      Signal completion
       LI   R0,1
       JMP  CPYEND

*      Signal error
CPYERR LI   R0,2
CPYEND MOV  R0,@GPURES
       IDLE
*// GPUCPY


***
* Perform the actual update by copying the bit stream from the staging
* sectors to the real sectors.
*
UPDSRC DATA >0A00
UPDDST DATA >0000
UPDLEN DATA >0600
GPUUPD
       A    @NEWLN,@LASTLN    * Next line for display

       LI   R4,GMSG1          * "CLEARING SECTOR"
       LI   R5,GMSG1E-GMSG1
       BSTK @SHOWTXT          * Leaves R6 at end of displayed text

       CLR  R1                * Clear sectors >0 through >5
       LI   R2,6              * Clear six sectors
       BSTK @SERASE           * Increments the current display line

*      Read >0A0000 to >0FFFFF and write to >000000 to >05FFFF
       A    @NEWLN,@LASTLN    * Next line for display
       LI   R4,GMSG4          * "UPDATING"
       LI   R5,GMSG4E-GMSG4
       BSTK @SHOWTXT          * Leaves R6 at end of displayed text
UPD_LP
       MOV  @UPDSRC,R0
       LI   R1,PABBUF
       LI   R2,256
       BSTK @BREAD

       MOV  @UPDDST,R0
       LI   R1,PABBUF
       LI   R2,256
       BSTK @BWRITE           * Displays page in R0 (0-4095)

       INC  @UPDSRC
       INC  @UPDDST
       DEC  @UPDLEN
       JNE  UPD_LP

       A    @NEWLN,@LASTLN    * Next line for display

       IDLE
*// GPUUPD


**
* Verify a block in the SPI by calculating the CRC
*
* GPUFNO = current file number, 1-based
* GPUBNO = current file block number
* BLKSIZ = size of data block in KiB
*
GPUVFY
       MOV  @GPUFNO,R0        * Check the file being copied
       DEC  R0                * File numbers are 1-based
       JNE  GVFY05
       CLR  R9                * Block for bit stream
       LI   R4,GMSG5          * "VERIFYING BIT STREAM"
       LI   R5,GMSG5E-GMSG5
       JMP  GVFY10
GVFY05
       LI   R9,>0500          * Block for data file
       LI   R4,GMSG6          * "VERIFYING DATA"
       LI   R5,GMSG6E-GMSG6
GVFY10
       BSTK @SHOWTXT          * Leaves R6 at end of displayed text

*      Read SPI block to PABBUF
*      The block number needs to be adjusted to a count of 256-byte blocks
       MOV  R9,R0
       LI   R1,BLKSIZ*1024/256               * 2 * 1024 / 256 = 8
       MOV  @GPUBNO,R2
       MPY  R1,R2             * Multiply the block number by 256-byte chunks (8) in one block
       A    R3,R0             * Add the 256-byte block count to the base address
       LI   R1,PABBUF
       LI   R2,BLKSIZ*1024
       BSTK @BREAD            * Reads SPI block into PABBUF
       BSTK @DSPHEX

*      Check CRC
       BSTK @CHKCRC
       MOV  R0,R0             * Check for error
       JNE  GVFY80            * Set error

*      Signal completion
       LI   R0,1
       JMP  GVFY99

*      Signal error
GVFY80 LI   R0,2
GVFY99 MOV  R0,@GPURES
       IDLE
*// GPUVFY


*********************************************************************
* Check and display the CRC for a block
*
* GPUCRC = expected CRC for the block
* PABBUF = block to check
* BLKSIZ = block size in whole KiB, i.e. 1, 2, etc. not 1024, 2048...

*      Calculate CRC
CHKCRC LI   R1,PABBUF
       LI   R2,BLKSIZ*1024
       BSTK @CRC16

*      Display calculated CRC
       MOV  R6,R2             * Save R6
       LI   R6,20*32+1+NAMETB
       LI   R1,GMSCRC         * "CRC:"
       MOVB *R1+,*R6+
       MOVB *R1+,*R6+
       MOVB *R1+,*R6+
       MOVB *R1+,*R6+
       BSTK @DSPHEX           * Shows the number in R0 as hex at R6

*      Compare with provided CRC
       C    @GPUCRC,R0
       JEQ  CHK80

*      Display expected CRC
       MOV  @GPUCRC,R0
       AI   R6,6
       BSTK @DSPHEX           * Shows the number in R0 as hex at R6

*      Signal failure
       SETO R0
       JMP  CHK90

*      Signal success
CHK80  CLR  R0

*      Return
CHK90  MOV  R2,R6             * Restore R6
       RSTK
*// CHKCRC


*********************************************************************
*
* Calculate CRC-16
*
* R1: Address of data buffer
* R2: Number of bytes to process
*
* Returns the result in R0
*
CRC16
*      unsigned short int crc = start;
*      int r;
       CLR  R0                  * R0 is crc
       CLR  R4                  * R4 is r
*      /* while there is more data to process */
*      while (n-- > 0) {
CRCLP
*      /* compute checksum of lower four bits of *p */
*      r = crc_16_table[crc & 0xF];
       MOV  R0,R3               * crc
       ANDI R3,>000F            * crc & 0xF
       SLA  R3,1                * Need word offset
       MOV  @CRC16T(R3),R4      * crc_16_table[crc & 0xF]
*      crc = (crc >> 4) & 0x0FFF;
       SRL  R0,4                * crc >> 4
       ANDI R0,>0FFF            * (crc >> 4) & 0x0FFF
*      crc = crc ^ r ^ crc_16_table[*p & 0xF];
       XOR  R4,R0               * crc ^ r
       MOVB *R1,R3              * *p
       SWPB R3                  * Move to LSB
       ANDI R3,>000F            * *p & 0xF
       SLA  R3,1                * Need word offset
       XOR  @CRC16T(R3),R0      * crc ^ r ^ crc_16_table[*p & 0xF]
*      /* now compute checksum of upper four bits of *p */
*      r = crc_16_table[crc & 0xF];
       MOV  R0,R3               * crc
       ANDI R3,>000F            * crc & 0xF
       SLA  R3,1                * Need word offset
       MOV  @CRC16T(R3),R4      * crc_16_table[crc & 0xF]
*      crc = (crc >> 4) & 0x0FFF;
       SRL  R0,4                * crc >> 4
       ANDI R0,>0FFF            * (crc >> 4) & 0x0FFF
*      crc = crc ^ r ^ crc_16_table[(*p >> 4) & 0xF];
       XOR  R4,R0               * crc ^ r
       MOVB *R1,R3              * *p
       SWPB R3                  * Move to LSB
       SRL  R3,4                * *p >> 4
       ANDI R3,>000F            * (*p >> 4) & 0xF
       SLA  R3,1                * Need word offset
       XOR  @CRC16T(R3),R0      * crc ^ r ^ crc_16_table[(*p >> 4) & 0xF]
*      /* next... */
*      p++;
       INC  R1
*      }
       DEC  R2
       JNE  CRCLP
       RSTK

CRC16T DATA >0000,>CC01,>D801,>1400
       DATA >F001,>3C00,>2800,>E401
       DATA >A001,>6C00,>7800,>B401
       DATA >5000,>9C01,>8801,>4400
*// CRC16


**
* Show text on line 15 (zero offset, i.e. line 16)
* R4 = Source address of text
* R5 = Length of text
* R6 = Output: VRAM address after the last displayed character
* Destroys R7
* Destroys R8
LASTLN DATA 14*32+0+NAMETB
NEWLN  DATA 32
SHOWTXT
       MOV  @LASTLN,R6
       LI   R7,>2020          * Space tile (32) to MSB and LSB
       LI   R8,16
SHOWL1 MOV  R7,*R6+           * Clear the line two tiles at a time
       DEC  R8
       JNE  SHOWL1
       MOV  @LASTLN,R6
SHOWL2 MOVB *R4+,*R6+
       DEC  R5
       JNE  SHOWL2
       RSTK                   * Return using stack
*// SHOWTXT

GMSG0  TEXT "0123456789ABCDEF"
GMSG0E
GMSG1  TEXT "CLEARING SECTOR: "
GMSG1E BYTE 17
GMSG2  TEXT "STAGING BIT STREAM: "
GMSG2E
GMSG3  TEXT "STAGING DATA: "
GMSG3E
GMSG4  TEXT "UPDATING: "
GMSG4E
GMSG5  TEXT "VERIFYING BIT STREAM: "
GMSG5E
GMSG6  TEXT "VERIFYING DATA: "
GMSG6E
GMSG7  TEXT "CLEANING UP: "
GMSG7E BYTE 13
GMSCRC TEXT "CRC:"
       EVEN


**
* Displays a hex value
*
* R0 = hex value to display, not changed
* R6 = screen location to display number, not changed
* R7 destroyed
* R8 destroyed

DSPHEX
*      Display the hex address in R0
       MOV  R6,R7             * Don't change R6 (display location)
       MOV  R0,R8
       SRA  R8,12
       ANDI R8,>000F
       MOVB @GMSG0(R8),*R7+
       MOV  R0,R8
       SRA  R8,8
       ANDI R8,>000F
       MOVB @GMSG0(R8),*R7+
       MOV  R0,R8
       SRA  R8,4
       ANDI R8,>000F
       MOVB @GMSG0(R8),*R7+
       MOV  R0,R8
       ANDI R8,>000F
       MOVB @GMSG0(R8),*R7+
       RSTK
*// DSPHEX


**
* Sector Erase
* Erase one or more 64K sectors
* Destroys R0
* R1 = first sector (>00 to >0F) to erase in MSB
* R2 = number of sectors
* Destroys R3
* R6 = location where sector can be displayed
SERASE
ERS_LP
       LI   R3,CMD_WE
       DATA CSON              * SPI Chip Enable
       LDCR R3,8              * Send Write Enable command
       DATA CSOFF             * SPI Chip Disable

       LI   R3,CMD_SE         * Send Sector Erase command
       DATA CSON              * SPI Chip Enable
       LDCR R3,8
       LDCR R1,8              * Send sector number as 1st byte in 24-bit address
       CLR  R0
       LDCR R0,8              * Send >00
       LDCR R0,8              * Send >00 as LSB of 24-bit address
       DATA CSOFF             * SPI Chip Disable

*      Wait until the sector erase is finished
       CLR  R3
       MOV  R1,R3             * Sector being erased is in MSB of R1
       SWPB R3                * Move to LSB of R5 for table addressing
       MOVB @GMSG0(R3),*R6+   * Convert to HEX digit and display

       BSTK @SPISTS           * Call using stack

       AI   R1,>0100          * Next sector in 24-bit address >0n0000
       DEC  R2
       JNE  ERS_LP

       RSTK                   * Return using stack
*// SERASE


**
* Block Write
* Write a block of data.  Blocks MUST BE multiple of 256 bytes (one SPI page).
* R0 = SPI page (0 to 4095) to begin writing >0ppp00
* R1 = Buffer to write
* R2 = Length of data to write
* Destroys R3
BWRITE
       BSTK @DSPHEX           * Shows the number in R0 as hex

       LI   R3,CMD_WE
       DATA CSON              * SPI Chip Enable
       LDCR R3,8              * Send Write Enable command
       DATA CSOFF             * SPI Chip Disable

       LI   R3,CMD_PP
       DATA CSON              * SPI Chip Enable
       LDCR R3,8              * Send Page Program command
       LDCR R0,8              * Send MSB of page address
       SWPB R0
       LDCR R0,8              * Send next byte of address
       SWPB R0                * Restore R0 for multiple page writes
       CLR  R3
       LDCR R3,8              * Send LSB of address, always >00

       LI   R3,256            * Each SPI page is 256 bytes
WRT_LP
       LDCR *R1+,8            * Send a byte of data
       DEC  R2
       JEQ  WRTEND            * Done with block
       DEC  R3                * Count the data in the current block
       JNE  WRT_LP            * More data in this page

*      Current page is done, so disable the SPI and wait for the page
*      write to commit.
WRTEND
       DATA CSOFF             * SPI Chip Disable
       INCT R6
       BSTK @SPISTS
       DECT R6
       INC  R0                * Next page >0ppp00
       MOV  R2,R2             * Test if the data is done or if only the current block was done
       JNE  BWRITE            * More data, start next page

       RSTK                   * Return using stack
*// BWRITE


**
* Block Read
* Read a block of data.  Blocks MUST BE multiple of 256 bytes (one SPI page).
* R0 = SPI page (0 to 4095) to begin reading >0ppp00
* R1 = Buffer to read into
* R2 = Length of data to read
* Destroys R3
BREAD
       LI   R3,CMD_RD
       DATA CSON              * SPI Chip Enable
       LDCR R3,8              * Send fast read command
       LDCR R0,8              * Send MSB of 24-bit page address
       SWPB R0
       LDCR R0,8              * Next address byte
       SWPB R0                * Restore R0
       CLR  R3
       LDCR R3,8              * Send LSB of address, always >00
       STCR R3,8              * Consume fast read dummy byte
RD_LP  STCR *R1+,8            * Read a byte into the specified buffer
       DEC  R2
       JNE  RD_LP

       DATA CSOFF             * SPI Chip Disable
       RSTK                   * Return using stack
*// BREAD


**
* SPI Status Check
* Wait for a write or erase command to finish
* Destroys R3
* R6 = Address in VRAM where an indicator can be displayed
* Destroys R7
* Destroys R8
SPISTS
       LI   R3,CMD_RS
       DATA CSON              * SPI Chip Enable
       LDCR R3,8              * Send Read Status command
STS_LP STCR R3,8              * Read status register
       ANDI R3,>0100          * Check if the WIP (write in progress) bit is set
       JNE  STS_LP            * WIP == 1 when a write is in progress, so wait if set
       DATA CSOFF             * SPI Chip Disable
       RSTK                   * Return using stack
*// SPISTS

       EVEN
GPUFNO DATA >0000               * GPU file number
GPUBNO DATA >0000               * GPU block number
GPUCRC DATA >0000               * GPU CRC of last block
GPURES DATA >0000               * GPU result (0=Working, 1=OK, 2=Error)
GPUEND

       END  START